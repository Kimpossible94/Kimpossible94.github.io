---
title : "[Algorithm] 시간복잡도 (Time Complexity) - 작성중"
excerpt : "시간복잡도에 대해 알아보자 !"
categories : 
    - Algorithm
tags :
    - [Algorithm, 알고리즘, Time Complexity, 시간복잡도]
toc : true
toc_sticky : true
date : 2022-06-28
last_modified_at: 2022-06-28
published: true
---


# 1. 시간복잡도란 ?
---
컴퓨터 프로그램의 입력값과 연산 수행 시간의 상관관게를 나타내는 척도를 말한다.  
일반적으로 시간복잡도는 <span class="h-text-p">점근 표기법</span>을 이용하여 나타낸다.  
  
## 점근 표기법
***컴퓨터 알고리즘의 수행 시간은 실행환경에 따라 다르게 측정된다.***  
동일한 알고리즘을 슈퍼컴퓨터와 내 노트북에서 수행할 때는 분명 속도 면에서 차이가 날 것이다.  
수행환경을 통제하지 않고서는 공정한 비교라고 할 수 없기 때문에 수행환경을 통제해야 한다.  
  
하지만, 수행환경을 통제하는 것은 어렵기 때문에 컴퓨터의 성능과 관계없이  
데이터 개수(n)가 주어졌을 때 <span class="h-text-p">기본 연산(덧셈, 뺄셈, 곱셈 등)의 실행 횟수</span>로 성능을 분석한다.  
연산의 실행 횟수는 데이터 개수(n)에 대한 함수로 표현한다.  
ex) \\(f(n) = n^2+3n+1 \\)  

이렇게 따져본 내 알고리즘의 계산복잡성이 \\(20/πn^2 + n + 100\\) 이고,  
다른 개발자가 내놓은 알고리즘은 \\(100000n + 100000\\)이라고 가정해보자.  

두 개의 알고리즘 중 어떤게 더 효율적인지 단박에 알아내기가 어렵다.  
이럴 때 가늠하려는 알고리즘의 복잡성 증가 양상을 단순화 시켜 우리가 익히 알고 있는  
로그, 지수, 다항함수 등과의 비교로 표현하는 것이 ***점근 표기법***이다.  

점근 표기법에서는 원래의 함수를 단순화하여 최고차항을 제외한 모든 항과 최고차항의 계수는 무시하고 <span class="h-text-p">최고차항의 차수만을 고려</span>한다.
이 표기법을 따르면 \\(20/πn^2 + n + 100\\)의 복잡도는 \\(n^2\\)이고, \\(100000n + 100000\\)의 복잡도는 \\(n\\)이다.

<p align="center"><img style="width:400px; height:400px" src="/assets/images/algorithm/time-1.png"></p>  
<center>x : 데이터, y : 시간</center>  
    
<br>
그래프를 보면 다른 개발자의 알고리즘보다 내가 만든 알고리즘이 데이터가 많아질수록 시간이 더 오래걸리는 것을 알 수 있다.

## 점근 표기법의 종류
접근 표기법의 대표적인 종류는 다음 세가지가 있다.  
- 오메가 표기법 (Big-Ω Noation)  
- 세타 표기법 (Big-θ Noation)  
- 빅오 표기법 (Big-O Noation)  


Big-O : 알고리즘의 성능을 수학적으로 표현해주는 표기법
알고리즘의 시간과 공간 복잡도를 표현할 수 있다.
알고리즘의 실제 러닝타임을 표시하는거라기 보다 데이터나 사용자의 증가율에따른 알고리즘의 성능을 에측하기때문에 상수와 같은 숫자는 모두 1이 된다.

O(1) : 입력 데이터의 크기와 상관없이 언제나 일정한 시간이 걸리는 알고리즘을 말한다.
O(n) : 입력 데이터의 크기에 정비례로 처리시간이 증가하는 알고리즘을 말한다.
O(n^2) : n이 이루는 면적만큼 처리시간이 증가한다.
O(nm) : n과 m이 이루는 면적만큼 처리시간이 증가한다.
O(n^3) : n이 이루는 큐빅만큼 처리시간이 증가한다.
O(2^n) : 피보나치 수열로 이루어지는 트리의 높이만큼 처리시간이 증가한다.
O(log n) : log n의 대표적인 알고리즘은 이진검색이다. 검색할 때 마다 처리해야할 데이터의 양이 절반씩 줄어드는 알고리즘을 말한다.